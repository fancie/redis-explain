  lzf压缩算法主要用于把redis的内容保存到文件里面，再用的时候（例如重启自动load）读取文件还原到redis内存。
  压缩可以分为无损压缩和有损压缩，有损，指的是压缩之后就无法完整还原原始信息，但是压缩率可以很高，主要应用于视频、话音等数据的压缩，因为损失了一点信息，人是很难察觉的，或者说，也没必要那么清晰照样可以看可以听；无损压缩则用于文件等等必须完整还原信息的场合，lzf明显用的是无损压缩。
  数据压缩都是把重复的内容用距离和长度表示，下面给个案例：
  原始数据：中国人都爱中国，中国太美了。  （utf-8总共52个字节）
  里面有3个“中国”，如果用utf-8格式存储总共消耗18个字节的数据，那如果压缩怎么表示呢？第二个“中国”，表示成往前移动15个字节（恰好到达第一个“中国”的位置），拷贝6个字节（15，6），第二个中国表示成（9，16）。
  最终压缩成这样：中国人都爱（15，6），（9，6）太美了。    （所以最终压缩成44个字节）
  压缩工具比这个复杂，常用的zip压缩做了很多其他设计，例如用Huffman编码把中国存储中“1”是不是更省空间了？这里具体怎么做的不再介绍，读者可以搜索相关的介绍。
  
  为什么我举上面的例子，lzf用的跟这个是类似的，下面我们来看看它怎么实现的。
  与压缩和解压的文字总共4个：
  lzf.h lzfP.h  lzf_c.c(压缩实现) lzf_d.c（解压实现）
  
  压缩：
  unsigned int
  lzf_compress (const void *const in_data, unsigned int in_len,
          void *out_data, unsigned int out_len
  #if LZF_STATE_ARG
                , LZF_STATE htab
  #endif
                )
  解压：
  unsigned int 
  lzf_decompress (const void *const in_data,  unsigned int in_len,
                  void             *out_data, unsigned int out_len)
  
  ###################分界线，以下进入具体实现####################
  
  **********压缩**********
  定义：
  LZF_STATE htab; // 65536个字节的数组，用于到时候匹配相同的字符
  const u8 *ip = (const u8 *)in_data; //待压缩内容
        u8 *op = (u8 *)out_data;  //存储压缩之后的内容
  const u8 *ref;  //匹配到相同内容的位置
  
  首先读取3个字节的内容
  hval = FRST (ip); //取2个字节，第0个字节和第1个字节
  hval = NEXT (hval, ip);   //扩转到3个字节，比较三个字节
  对3个字节做一次简单的hash，为什么是16位呢？因为htab里面的大小是：2^16，每次的hash值保存到htab的某个指针，下次如果计算出来是同样的hash值，就说明有可能是同样的内容（不一定相同，还需要逐个字节比较）
  htab + IDX (hval); //IDX：右移八位-5*h & 16个1，简单的hash算法，获取低16位，范围缩减到0-65535，然后把指针指向赋值给hslot
  
  ####如果没有匹配到相同的
  lit++; //未匹配 +1
  *op++ = *ip++;    //未匹配的时候把ip的内容赋值到op，然后指针往前挪一步。
  
  ####如果匹配了相同的内容
  首先记录本次未匹配的有多少个，保存op里面本轮未匹配内容的首字节
  如果结果是这样的：7 h e l l o.......，解压程序读到7的时候知道接下来需要读取8个字节（为什么是8个？程序这么设计的，解压程序也会进行一次++操作）
  op [- lit - 1] = lit - 1; /* stop run */  //记录本次读取了多少个字节
  op -= !lit; /* undo run if length is zero *
  
  接下来计算多少的偏移距离和多少个相同的字节
  if (len < 7){
      *op++ = (off >> 8) + (len << 5);  //高3位存放重复字节长度，余下的5位以及下一个字节的8位总共13位存放偏移
    }
  else{
      *op++ = (off >> 8) + (  7 << 5);  //高三位固定位：111
      *op++ = len - 7;  //大于7的部分存放到这个字节
    }
  *op++ = off;  //存放低8位的偏移内容，最多13个字节，受MAX_OFF控制
  总共偏移距离和相同字节长度用2-3个字节表示，如果相同字节长度小于7只用2个字节，大于等于7使用3个字节
  其中小于7的情况：
    第一个字节：高3位存放重复字节长度，低5位存放偏移距离的高5位。
    第二个字节：偏移距离的低8位，总的偏移距离是13位。
  大于等于7的情况：
    第一个字节：高3位存放固定的111（长度为7），低5位存放偏移距离的高5位。
    第二个字节：长度-7，到时候需要把第一个字节的高3位的数值加上这个字节的数值。
    第三个字节：偏移距离的低8位，总的偏移距离是13位。
  
  程序重复执行上述内容，到倒数第三个字节（匹配需要3个字节）
  最后2个字节直接拼接到op里面。
  
  #########实例#########
  输入待压缩内容：helloxhelloyhellofancie（这里重复的内容是3个hello，总共23个字节）
  
  
  **********解压**********
