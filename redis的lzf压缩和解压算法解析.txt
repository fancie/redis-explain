  redis里面的lzf压缩和解压算法主要用于把redis的内容保存到文件里面，再用的时候（例如重启自动load）读取文件还原到redis内存。
  压缩可以分为无损压缩和有损压缩，有损，指的是压缩之后就无法完整还原原始信息，但是压缩率可以很高，主要应用于视频、话音等数据的压缩，因为损失了一点信息，
人是很难察觉的，或者说，也没必要那么清晰照样可以看可以听；无损压缩则用于文件等等必须完整还原信息的场合，lzf明显用的是无损压缩。
  数据压缩基本上都是把重复的内容用距离和长度表示，下面给个案例：
  原始数据：中国人都爱中国，中国太美了。  （utf-8总共52个字节）
  里面有3个“中国”，如果用utf-8格式存储总共消耗18个字节的数据，那如果使用压缩怎么表示呢？第二个“中国”，表示成往前移动15个字节（恰好到达第一个“中国”的位置），
拷贝6个字节，用（15，6）表示，第二个中国则表示成（9，16）。
  最终压缩成这样：中国人都爱（15，6），（9，6）太美了。    （所以最终压缩成44个字节，举例简单，没有考虑具体实现怎么区分接下来读取具体内容还是偏移举例和长度）
  压缩工具比这个复杂，例如常用的zip压缩做了很多其他设计，比如用Huffman编码把中国存储用“1”表示是不是更省空间了？这里具体怎么实现的不再介绍，读者可以搜索相关的介绍。
  
  为什么我举上面的例子，redis里面的lzf算法用的跟这个是类似的，下面我们来看看它怎么实现的。
  
  redis与压缩和解压的文件总共4个：
  lzf.h lzfP.h  lzf_c.c(压缩实现) lzf_d.c（解压实现）
  
  压缩方法：
  unsigned int
  lzf_compress (const void *const in_data, unsigned int in_len,
          void *out_data, unsigned int out_len
  #if LZF_STATE_ARG
                , LZF_STATE htab
  #endif
                )
  解压方法：
  unsigned int 
  lzf_decompress (const void *const in_data,  unsigned int in_len,
                  void             *out_data, unsigned int out_len)
  
  ###################华丽的分界线，以下进入具体实现####################
  ******************压缩********************
  部分定义：
  LZF_STATE htab; // 65536个字节的数组，用于到时候匹配相同的内容
  const u8 *ip = (const u8 *)in_data; //待压缩内容
        u8 *op = (u8 *)out_data;  //存储压缩之后的内容
  const u8 *ref;  //匹配到相同内容的位置
  
  首先读取3个字节的内容
  hval = FRST (ip); //取2个字节，第0个字节和第1个字节
  hval = NEXT (hval, ip);   //扩转到3个字节，hash比较三个字节
  对3个字节做一次简单的hash，为什么是16位呢？因为htab里面的大小是：2^16，每次的hash值保存到htab的某个指针，下次如果计算出来是同样的hash值，就说明
有可能是同样的内容（不一定相同，还需要逐个字节比较）
  htab + IDX (hval); //IDX：右移八位-5*h & 16个1，简单的hash算法，获取低16位，范围压缩到0-65535，然后把指针指向赋值给hslot
  
  ####如果没有匹配到相同的
  lit++; //未匹配 +1
  *op++ = *ip++;    //未匹配的时候把ip的内容赋值到op，然后指针往前挪一步。
  
  ####如果匹配了相同的内容
  首先记录本次未匹配的有多少个字节，保存op里面的本轮未匹配内容的第一个字节
  如果匹配结果是这样的：7 h e l l o.......，解压程序读到7的时候知道接下来需要读取8个字节（为什么是8个？程序这么设计的，设置了最大读取长度，解压程序也会进行一次++操作）。
  op [- lit - 1] = lit - 1; /* stop run */  //记录本次读取了多少个字节
  op -= !lit; /* undo run if length is zero *
  
  接下来计算多少的偏移距离和多少个相同的字节
  if (len < 7){
      *op++ = (off >> 8) + (len << 5);  //高3位存放重复字节长度，余下的5位以及下一个字节的8位总共13位存放偏移位置
    }
  else{
      *op++ = (off >> 8) + (  7 << 5);  //高3位固定位：111（7）
      *op++ = len - 7;  //大于7的部分存放到这个字节
    }
  *op++ = off;  //存放低8位的偏移内容，最多13个字节，受MAX_OFF控制
  总共偏移距离和相同字节长度用2-3个字节表示，如果相同字节长度小于7只用两个字节，大于等于7使用3个字节表示
  其中小于7的情况：
    第一个字节：高3位存放重复字节长度，低5位存放偏移距离的高5位（偏移距离最大2^13）。
    第二个字节：偏移距离的低8位，总的偏移距离是13位。
  大于等于7的情况：
    第一个字节：高3位存放固定的111（长度为7），低5位存放偏移距离的高5位（偏移距离最大2^13）。
    第二个字节：长度-7，到时候需要把第一个字节的高3位的数值加上这个字节的数值。
    第三个字节：偏移距离的低8位，总的偏移距离是13位。
  
  程序重复执行上述内容，到倒数第三个字节（匹配至少需要3个字节）
  最后2个字节直接拼接到op里面，记录读取多少个字节。
  
  #########实例#########
  输入待压缩内容：helloworldxhelloworldyhelloworldfancie（这里重复的内容是3个helloworld，总共38个字节）
  
  我们观察一下op里面的内容
  开始空一个字节，这时：
  op = 0
  继续读取6个字节
  op = 0 h e l l o w o r l d x（中间的空格便于观察）
  读取到第12个字节的时候，发现有相同的内容（这里我把官方代码：&& ref > (u8 *)in_data 的 ">" 修改成了 “>=”）
  记录读取内容
  op = 10 h e l l o w o r l d x 
  记录偏移距离和重复长度
  op = 10 h e l l o w o r l d x 224 1 10
  继续空一个字节
  op = 10 h e l l o w o r l d x 224 1 10 0
  继续读取y
  op = 10 h e l l o w o r l d x 224 1 10 0 y （y前面一个0不需要修改成1，因为解压会做一次++）
  继续读取又碰到重复的内容
  op = 10 h e l l o w o r l d x 224 1 10 0 y 224 1 10
  继续空一个字节
  op = 10 h e l l o w o r l d x 224 1 10 0 y 224 1 10 0
  继续读取后面的fancie
  op = 10 h e l l o w o r l d x 224 1 10 0 y 224 1 10 0 f a n c i e
  记录最后一次读取长度
  op = 10 h e l l o w o r l d x 224 1 10 0 y 224 1 10 5 f a n c i e
  ####压缩到此结束
  整个字符串压缩到27个字节
  
  程序输出：
  压缩前：val = helloworldxhelloworldyhelloworldfancie
  压缩前：len = 38

  压缩后：val = helloworldx....（后面有乱码）
  压缩后：len = 27
  
  压缩过程还有许多具体处理细节，这里并没有写的太详细。
  
  ******************解压********************
  解压其实比较简单，代码很好读
  
  开始读取第一个字节
  unsigned int ctrl = *ip++;
  if (ctrl < (1 << 5)){
    这种情况只需要解析来读取ctrl+1个字节写入到op中。
  }else{
    有重复的内容，需要挪动指针到op当前指针的偏移位置
    计算偏移位置和重复长度，具体参考压缩过程。
      如果高3位等于7，说明本次记录偏移位置和长度需要读取三个字节
      如果高3位小于7，说明本次记录偏移位置和长度需要读取两个字节
    然后再读取具体长度的内容写入到op中。
  }
  压缩过程我就不列出具体内容了。
  
  程序输出：
  解压前：val = helloworldx....（后面有乱码）
  解压前：len = 27
  
  解压后：val = helloworldxhelloworldyhelloworldfancie
  解压后：len = 38
  
  -------------------------------------------------------------
  2020年7月2日整理于杭州
  --fancie
